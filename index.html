<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <title>‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏£‡∏ñ‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <!-- jsPDF (UMD) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  
  <!-- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ jsPDF ‡πÅ‡∏ö‡∏ö global ‡∏à‡∏≤‡∏Å UMD -->
  <script>
    if (window.jspdf && window.jspdf.jsPDF) {
      // ‡πÉ‡∏´‡πâ‡∏°‡∏µ‡∏ó‡∏±‡πâ‡∏á window.jspdf.jsPDF (UMD) ‡πÅ‡∏•‡∏∞ window.jsPDF (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏•‡∏±‡πä‡∏Å‡∏≠‡∏¥‡∏ô/‡∏ü‡∏≠‡∏ô‡∏ï‡πå‡∏ó‡∏µ‡πà‡∏≠‡πâ‡∏≤‡∏á jsPDF.API)
      window.jsPDF = window.jspdf.jsPDF;
    }
  </script>
  
  <!-- AutoTable ‡∏ï‡πâ‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏°‡∏µ window.jsPDF ‡πÅ‡∏•‡πâ‡∏ß -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
  
  <!-- ‡∏ü‡∏≠‡∏ô‡∏ï‡πå Sarabun (‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏¢‡∏π‡πà‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö index.html) -->
  <!-- ‡πÑ‡∏ü‡∏•‡πå‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏Å jsPDF.API.addFileToVFS / addFont ‡πÉ‡∏´‡πâ‡πÄ‡∏≠‡∏á -->
  <script src="./Sarabun-Regular-normal.js"></script>

  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
    }
    header {
      padding: 12px 16px;
      background: #1f2937;
      color: #fff;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    header h1 {
      font-size: 18px;
      margin: 0;
    }
    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      font-size: 13px;
    }
    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .filter-group label {
      font-size: 11px;
      color: #e5e7eb;
    }
    .filter-group input,
    .filter-group select,
    .filter-group button {
      font-size: 12px;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #9ca3af;
    }
    .filter-group button {
      border: none;
      cursor: pointer;
      background: #3b82f6;
      color: white;
      font-weight: 600;
    }
    .filter-group button.secondary {
      background: #6b7280;
    }

    /* ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ‡∏õ‡∏∏‡πà‡∏° Export */
    button#exportExcelBtn {
      background: #16a34a !important;
      color: white !important;
      border: none !important;
    }

    button#exportPdfBtn {
      background: #f97316 !important;
      color: white !important;
      border: none !important;
    }

    #map {
      width: 100%;
      height: calc(100vh - 70px);
    }

    .legend {
      background: white;
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1.5;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.25);
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid #4b5563;
    }

    .status-bar {
      position: absolute;
      z-index: 500;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(31,41,55,0.85);
      color: #e5e7eb;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
    }

    .summary-box {
      background: white;
      padding: 10px 12px;
      font-size: 14px;
      line-height: 1.6;
      border-radius: 8px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.3);
      max-width: 320px;
      margin-top: 48px;
    }
    .summary-box-title {
      font-weight: 700;
      font-size: 15px;
      margin-bottom: 8px;
    }
    .summary-item {
      margin-bottom: 8px;
    }

    /* ====== LOGIN OVERLAY ====== */
    .login-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .login-box {
      background: #ffffff;
      border-radius: 12px;
      padding: 20px 22px;
      width: 280px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      text-align: center;
    }
    .login-box h2 {
      margin: 0 0 12px 0;
      font-size: 18px;
      color: #111827;
    }
    .login-box p {
      margin: 0 0 16px 0;
      font-size: 12px;
      color: #6b7280;
    }
    .login-field {
      text-align: left;
      margin-bottom: 10px;
    }
    .login-field label {
      font-size: 12px;
      color: #374151;
      display: block;
      margin-bottom: 4px;
    }
    .login-field input {
      width: 100%;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #d1d5db;
      font-size: 13px;
      box-sizing: border-box;
    }
    .login-box button {
      margin-top: 8px;
      width: 100%;
      padding: 6px 8px;
      border-radius: 999px;
      border: none;
      background: #3b82f6;
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-size: 13px;
    }
    .login-box button:hover {
      background: #2563eb;
    }
    .login-error {
      margin-top: 6px;
      font-size: 12px;
      color: #b91c1c;
      min-height: 16px;
    }
  </style>
</head>
<body>
  <!-- LOGIN OVERLAY -->
  <div id="loginOverlay" class="login-overlay">
    <div class="login-box">
      <h2>‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö</h2>
      <p>‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å ID ‡πÅ‡∏•‡∏∞ Password ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà</p>
      <div class="login-field">
        <label for="loginId">ID</label>
        <input type="text" id="loginId" />
      </div>
      <div class="login-field">
        <label for="loginPass">Password</label>
        <input type="password" id="loginPass" />
      </div>
      <button id="loginBtn">‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö</button>
      <div id="loginError" class="login-error"></div>
    </div>
  </div>

  <header>
    <h1>üìç ‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏£‡∏ñ‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô 2568</h1>
    <div class="filters">
      <div class="filter-group">
        <label for="startDatetime">‡∏à‡∏≤‡∏Å‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤ (Start)</label>
        <input type="datetime-local" id="startDatetime" />
      </div>
      <div class="filter-group">
        <label for="endDatetime">‡∏ñ‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤ (End)</label>
        <input type="datetime-local" id="endDatetime" />
      </div>
      <div class="filter-group">
        <label for="licenseSelect">‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏£‡∏ñ</label>
        <select id="licenseSelect">
          <option value="">‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</option>
        </select>
      </div>
      <div class="filter-group">
        <label for="driverSelect">‡∏ä‡∏∑‡πà‡∏≠ ‡∏û‡∏Ç‡∏£</label>
        <select id="driverSelect">
          <option value="">‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</option>
        </select>
      </div>
      <div class="filter-group">
        <label>&nbsp;</label>
        <button id="applyFilterBtn">Apply Filter</button>
      </div>
      <div class="filter-group">
        <label>&nbsp;</label>
        <button id="resetFilterBtn" class="secondary">Reset</button>
      </div>
      <!-- ‡∏õ‡∏∏‡πà‡∏° Export -->
      <div class="filter-group">
        <label>&nbsp;</label>
        <button id="exportExcelBtn" class="secondary">Export Excel</button>
      </div>
      <div class="filter-group">
        <label>&nbsp;</label>
        <button id="exportPdfBtn" class="secondary">Export PDF</button>
      </div>
    </div>
  </header>

  <div id="map"></div>
  <div class="status-bar" id="statusBar">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Google Sheets...</div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- PapaParse -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    const SHEET_CSV_URL =
      "https://docs.google.com/spreadsheets/d/1hjEeceDdHwOgZ4hbcE8bOfitZVhKB7KBtVHmF5p4iGY/export?format=csv&gid=365287996";

    const PARKING_CSV_URL =
      "https://docs.google.com/spreadsheets/d/1hjEeceDdHwOgZ4hbcE8bOfitZVhKB7KBtVHmF5p4iGY/export?format=csv&gid=1849750877";

    const REF_CSV_URL =
      "https://docs.google.com/spreadsheets/d/1hjEeceDdHwOgZ4hbcE8bOfitZVhKB7KBtVHmF5p4iGY/export?format=csv&gid=1061454761";

    const COLUMN = {
      license: "‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô",
      datetime: "‡∏ß‡∏±‡∏ô‡πÅ‡∏•‡∏∞‡πÄ‡∏ß‡∏•‡∏≤",
      lat: "‡∏•‡∏∞",
      lng: "‡∏•‡∏≠‡∏á",
      org: "‡∏™‡∏±‡∏á‡∏Å‡∏±‡∏î",
      distance: "‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏∏‡∏î‡πÉ‡∏Å‡∏•‡πâ‡∏™‡∏∏‡∏î",
      locationText: "‡∏£‡∏∞‡∏ö‡∏∏‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà",
      driver: "‡∏ä‡∏∑‡πà‡∏≠ ‡∏û‡∏Ç‡∏£"
    };

    const PARKING_COLUMN = {
      lat: "‡∏•‡∏∞",
      lng: "‡∏•‡∏≠‡∏á",
      name: "‡∏ä‡∏∑‡πà‡∏≠‡∏à‡∏∏‡∏î",
      locationText: "‡∏£‡∏∞‡∏ö‡∏∏‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà",
      note: "‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏"
    };

    let rawData = [];
    let parkingData = [];
    let refData = [];

    let map, markersLayer, parkingLayer;
    let summaryControl;
    const licenseColorMap = {};

    const FIXED_LICENSE_COLORS = {
      "70-1873-63": "#cc0000",
      "70-1927-64": "#1d4ed8",
      "70-2484-70": "#eab308"
    };

    const colorPalette = [
      "#ec4899",
      "#6366f1",
      "#f97316",
      "#22c55e",
      "#a855f7",
      "#f59e0b",
      "#fb7185"
    ];

    const MIN_STOP_MS = 3 * 60 * 1000;

    function updateStatus(text) {
      document.getElementById("statusBar").textContent = text;
    }

    function normalizeLicense(license) {
      if (!license) return "";
      return String(license).trim();
    }

    function getColorForLicense(license) {
      const key = normalizeLicense(license);
      if (!key) return "#000000";

      if (FIXED_LICENSE_COLORS[key]) {
        licenseColorMap[key] = FIXED_LICENSE_COLORS[key];
        return FIXED_LICENSE_COLORS[key];
      }

      if (!licenseColorMap[key]) {
        const index = Object.keys(licenseColorMap).length % colorPalette.length;
        licenseColorMap[key] = colorPalette[index];
      }
      return licenseColorMap[key];
    }

    function parseDateTime(str) {
      if (!str) return null;
      const s = String(str).trim();
      const [datePart, timePart] = s.split(" ");
      if (!datePart || !timePart) return null;
      const [y, m, d] = datePart.split("-").map(Number);
      const [hh, mm = 0, ss = 0] = timePart.split(":").map(Number);
      if ([y, m, d].some(v => isNaN(v))) return null;
      return new Date(y, m - 1, d, hh || 0, mm || 0, ss || 0);
    }

    function haversineMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    const TRAFFIC_LIGHT_ZONES = [];

    function isInTrafficLightZone(lat, lng) {
      for (const z of TRAFFIC_LIGHT_ZONES) {
        const d = haversineMeters(lat, lng, z.lat, z.lng);
        if (d <= z.radiusMeters) return true;
      }
      return false;
    }

    function parseRefLatLng(row) {
      let lat = NaN;
      let lng = NaN;

      for (const [key, value] of Object.entries(row)) {
        const lowerKey = key.toLowerCase();
        if (Number.isNaN(lat) && (lowerKey.includes("‡∏•‡∏∞") || lowerKey.includes("lat"))) {
          const n = parseFloat(value);
          if (!Number.isNaN(n)) lat = n;
        }
        if (Number.isNaN(lng) && (lowerKey.includes("‡∏•‡∏≠‡∏á") || lowerKey.includes("lng") || lowerKey.includes("lon"))) {
          const n = parseFloat(value);
          if (!Number.isNaN(n)) lng = n;
        }
      }

      if (Number.isNaN(lat) || Number.isNaN(lng)) {
        const nums = Object.values(row)
          .map(v => parseFloat(v))
          .filter(n => !Number.isNaN(n));

        for (let i = 0; i < nums.length - 1; i++) {
          const a = nums[i];
          const b = nums[i + 1];
          if (a >= 5 && a <= 25 && b >= 95 && b <= 110) {
            lat = a;
            lng = b;
            break;
          }
        }
      }

      return { lat, lng };
    }

    function isInRefZone(lat, lng) {
      if (!refData.length) return false;
      for (const p of refData) {
        const d = haversineMeters(lat, lng, p.lat, p.lng);
        if (d <= 300) return true;
      }
      return false;
    }

    function getFilteredData() {
      const startInput = document.getElementById("startDatetime").value;
      const endInput = document.getElementById("endDatetime").value;
      const licenseFilter = document.getElementById("licenseSelect").value;
      const driverFilter = document.getElementById("driverSelect").value;

      const start = startInput ? new Date(startInput) : null;
      const end = endInput ? new Date(endInput) : null;

      return rawData.filter(row => {
        const lat = parseFloat(row[COLUMN.lat]);
        const lng = parseFloat(row[COLUMN.lng]);
        if (isNaN(lat) || isNaN(lng)) return false;

        if (isInTrafficLightZone(lat, lng)) return false;
        if (isInRefZone(lat, lng)) return false;

        const dt = parseDateTime(row[COLUMN.datetime]);
        if ((start || end) && !dt) return false;
        if (start && dt < start) return false;
        if (end && dt > end) return false;

        if (licenseFilter && row[COLUMN.license] !== licenseFilter) return false;
        if (driverFilter && row[COLUMN.driver] !== driverFilter) return false;

        return true;
      });
    }

    function updateLicenseOptionsByCurrentFilters() {
      const startInput = document.getElementById("startDatetime").value;
      const endInput = document.getElementById("endDatetime").value;
      const driverFilter = document.getElementById("driverSelect").value;
      const licenseSelect = document.getElementById("licenseSelect");

      const start = startInput ? new Date(startInput) : null;
      const end = endInput ? new Date(endInput) : null;

      const prevValue = licenseSelect.value;
      const licenseSet = new Set();

      rawData.forEach(row => {
        const lat = parseFloat(row[COLUMN.lat]);
        const lng = parseFloat(row[COLUMN.lng]);
        if (isNaN(lat) || isNaN(lng)) return;
        if (isInTrafficLightZone(lat, lng)) return;
        if (isInRefZone(lat, lng)) return;

        const dt = parseDateTime(row[COLUMN.datetime]);
        if ((start || end) && !dt) return;
        if (start && dt < start) return;
        if (end && dt > end) return;
        if (driverFilter && row[COLUMN.driver] !== driverFilter) return;

        if (row[COLUMN.license]) licenseSet.add(row[COLUMN.license]);
      });

      while (licenseSelect.options.length > 1) {
        licenseSelect.remove(1);
      }

      Array.from(licenseSet).sort().forEach(lic => {
        const opt = document.createElement("option");
        opt.value = lic;
        opt.textContent = lic;
        licenseSelect.appendChild(opt);
      });

      if (prevValue && licenseSet.has(prevValue)) {
        licenseSelect.value = prevValue;
      } else {
        licenseSelect.value = "";
      }
    }

    function updateDriverOptionsByCurrentFilters() {
      const startInput = document.getElementById("startDatetime").value;
      const endInput = document.getElementById("endDatetime").value;
      const licenseFilter = document.getElementById("licenseSelect").value;
      const driverSelect = document.getElementById("driverSelect");

      const start = startInput ? new Date(startInput) : null;
      const end = endInput ? new Date(endInput) : null;

      const prevValue = driverSelect.value;
      const driverSet = new Set();

      rawData.forEach(row => {
        const lat = parseFloat(row[COLUMN.lat]);
        const lng = parseFloat(row[COLUMN.lng]);
        if (isNaN(lat) || isNaN(lng)) return;
        if (isInTrafficLightZone(lat, lng)) return;
        if (isInRefZone(lat, lng)) return;

        const dt = parseDateTime(row[COLUMN.datetime]);
        if ((start || end) && !dt) return;
        if (start && dt < start) return;
        if (end && dt > end) return;
        if (licenseFilter && row[COLUMN.license] !== licenseFilter) return;

        if (row[COLUMN.driver]) driverSet.add(row[COLUMN.driver]);
      });

      while (driverSelect.options.length > 1) {
        driverSelect.remove(1);
      }

      Array.from(driverSet).sort().forEach(drv => {
        const opt = document.createElement("option");
        opt.value = drv;
        opt.textContent = drv;
        driverSelect.appendChild(opt);
      });

      if (prevValue && driverSet.has(prevValue)) {
        driverSelect.value = prevValue;
      } else {
        driverSelect.value = "";
      }
    }

    function populateFilters() {
      updateLicenseOptionsByCurrentFilters();
      updateDriverOptionsByCurrentFilters();
    }

    function resetFilters() {
      document.getElementById("startDatetime").value = "";
      document.getElementById("endDatetime").value = "";
      document.getElementById("licenseSelect").value = "";
      document.getElementById("driverSelect").value = "";
      updateLicenseOptionsByCurrentFilters();
      updateDriverOptionsByCurrentFilters();
      renderMap();
    }

    function initMap() {
      map = L.map("map").setView([16.3, 103.3], 7);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);
      markersLayer = L.layerGroup().addTo(map);
      parkingLayer = L.layerGroup().addTo(map);

      summaryControl = L.control({ position: "topleft" });
      summaryControl.onAdd = function () {
        const div = L.DomUtil.create("div", "summary-box");
        div.id = "summaryBox";
        div.innerHTML = `
          <div class="summary-box-title">‡∏™‡∏£‡∏∏‡∏õ‡∏à‡∏≠‡∏î‡∏ô‡∏≠‡∏Å‡∏à‡∏∏‡∏î</div>
          <div>‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡πà‡∏≠‡∏ô</div>
        `;
        return div;
      };
      summaryControl.addTo(map);
    }

    function clusterByRadius(data, radiusMeters = 300) {
      const clusters = [];
      const MAX_CLUSTER_SPAN_MS = 20 * 60 * 60 * 1000;

      const enriched = data
        .map(row => ({
          row,
          dt: parseDateTime(row[COLUMN.datetime])
        }))
        .sort((a, b) => (a.dt || 0) - (b.dt || 0));

      enriched.forEach(({ row, dt }) => {
        const lat = parseFloat(row[COLUMN.lat]);
        const lng = parseFloat(row[COLUMN.lng]);
        if (isNaN(lat) || isNaN(lng)) return;

        let found = null;

        for (const cluster of clusters) {
          const d = haversineMeters(lat, lng, cluster.lat, cluster.lng);
          if (d > radiusMeters) continue;
          if (!dt || !cluster.maxDt) continue;

          const diffMs = dt - cluster.maxDt;
          if (diffMs >= 0 && diffMs <= MAX_CLUSTER_SPAN_MS) {
            found = cluster;
            break;
          }
        }

        if (found) {
          found.rows.push(row);
          if (dt) {
            if (!found.minDt || dt < found.minDt) found.minDt = dt;
            if (!found.maxDt || dt > found.maxDt) found.maxDt = dt;
          }
        } else {
          clusters.push({
            lat,
            lng,
            rows: [row],
            minDt: dt || null,
            maxDt: dt || null
          });
        }
      });

      return clusters;
    }

    function getParkingLatLng(row) {
      let lat = parseFloat(
        row[PARKING_COLUMN.lat] ??
        row["‡∏•‡∏∞"] ??
        row["Lat"] ??
        row["LAT"] ??
        row["lat"]
      );

      let lng = parseFloat(
        row[PARKING_COLUMN.lng] ??
        row["‡∏•‡∏≠‡∏á"] ??
        row["Lon"] ??
        row["LON"] ??
        row["Lng"] ??
        row["LNG"] ??
        row["Long"] ??
        row["long"]
      );

      if (!Number.isNaN(lat) && !Number.isNaN(lng)) {
        return { lat, lng };
      }

      let candLat = NaN;
      let candLng = NaN;

      for (const [key, value] of Object.entries(row)) {
        const lowerKey = key.toLowerCase();
        const valStr = String(value).replace(",", ".");
        const num = parseFloat(valStr);
        if (Number.isNaN(num)) continue;

        if (Number.isNaN(candLat) && (lowerKey.includes("‡∏•‡∏∞") || lowerKey.includes("lat"))) {
          candLat = num;
          continue;
        }
        if (
          Number.isNaN(candLng) &&
          (lowerKey.includes("‡∏•‡∏≠‡∏á") || lowerKey.includes("lng") || lowerKey.includes("lon") || lowerKey.includes("long"))
        ) {
          candLng = num;
          continue;
        }
      }

      if (!Number.isNaN(candLat) && !Number.isNaN(candLng)) {
        return { lat: candLat, lng: candLng };
      }

      for (const value of Object.values(row)) {
        const str = String(value).replace(",", ".");
        const matches = str.match(/-?\d+(\.\d+)?/g);
        if (!matches || matches.length < 2) continue;

        const a = parseFloat(matches[0]);
        const b = parseFloat(matches[1]);

        if (a >= -90 && a <= 90 && b >= -180 && b <= 180) {
          return { lat: a, lng: b };
        }
      }

      const nums = Object.values(row)
        .map(v => parseFloat(String(v).replace(",", ".")))
        .filter(n => !Number.isNaN(n));

      for (let i = 0; i < nums.length - 1; i++) {
        const a = nums[i];
        const b = nums[i + 1];
        if (a >= -90 && a <= 90 && b >= -180 && b <= 180) {
          return { lat: a, lng: b };
        }
      }

      return { lat: NaN, lng: NaN };
    }

    function getNearestParking(lat, lng) {
      if (!parkingData.length) {
        return { name: "-", distanceMeters: NaN, row: null };
      }

      let bestRow = null;
      let bestDist = Infinity;

      parkingData.forEach(row => {
        const { lat: plat, lng: plng } = getParkingLatLng(row);
        if (Number.isNaN(plat) || Number.isNaN(plng)) return;

        const d = haversineMeters(lat, lng, plat, plng);
        if (d < bestDist) {
          bestDist = d;
          bestRow = row;
        }
      });

      if (!bestRow || !isFinite(bestDist)) {
        return { name: "-", distanceMeters: NaN, row: null };
      }

      const vals = Object.values(bestRow);
      const name =
        bestRow[PARKING_COLUMN.name] ||
        bestRow[PARKING_COLUMN.locationText] ||
        bestRow["‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà"] ||
        vals[0] ||
        "-";

      return { name, distanceMeters: bestDist, row: bestRow };
    }

    function computeLicenseSummary(data) {
      const result = {};
      if (!data.length) return result;

      const licenseMap = new Map();
      data.forEach(row => {
        const rawLic = row[COLUMN.license] || "‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô";
        const lic = normalizeLicense(rawLic) || "‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô";
        if (!licenseMap.has(lic)) licenseMap.set(lic, []);
        licenseMap.get(lic).push(row);
      });

      licenseMap.forEach((rows, lic) => {
        const clusters = clusterByRadius(rows, 300);
        let count = 0;

        clusters.forEach(cluster => {
          const { lat, lng, rows: cRows } = cluster;
          if (!cRows.length) return;
          if (isInRefZone(lat, lng)) return;

          const sortedRows = cRows
            .map(r => ({ dt: parseDateTime(r[COLUMN.datetime]) }))
            .sort((a, b) => (a.dt || 0) - (b.dt || 0));

          const firstDt = sortedRows[0].dt;
          const lastDt  = sortedRows[sortedRows.length - 1].dt;

          if (firstDt && lastDt) {
            const diffMs = lastDt - firstDt;
            if (diffMs < MIN_STOP_MS) return;
          }
          count++;
        });

        if (count > 0) result[lic] = count;
      });

      return result;
    }

    function renderParkingMarkers(boundsArray) {
      parkingLayer.clearLayers();
      if (!parkingData.length) return;

      const defaultIcon = L.icon({
        iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png",
        iconRetinaUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png",
        shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
        iconSize: [28, 44],
        iconAnchor: [14, 44],
        popupAnchor: [0, -32],
        shadowSize: [41, 41]
      });

      parkingData.forEach(row => {
        const { lat, lng } = getParkingLatLng(row);
        if (Number.isNaN(lat) || Number.isNaN(lng)) return;

        const vals = Object.values(row);
        const name =
          row[PARKING_COLUMN.name] ||
          row[PARKING_COLUMN.locationText] ||
          row["‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà"] ||
          vals[0] ||
          "-";

        const note = row[PARKING_COLUMN.note] || "";

        const popupHtml = `
          <div style="font-size:13px;">
            <strong>‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î/‡∏ó‡∏µ‡πà‡∏à‡∏≠‡∏î‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô:</strong> ${name}<br/>
            ${note ? `<strong>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:</strong> ${note}<br/>` : ""}
            <strong>Lat,Lng:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br/>
            <a href="https://www.google.com/maps?q=${lat},${lng}" target="_blank" rel="noopener noreferrer">
              ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ô Google Maps
            </a>
          </div>
        `;

        const m = L.marker([lat, lng], { icon: defaultIcon });
        m.bindPopup(popupHtml);
        m.bindTooltip(name, { direction: "top", offset: [0, -28] });
        m.addTo(parkingLayer);

        if (boundsArray) boundsArray.push([lat, lng]);
      });
    }

    function formatDateInputToDDMMYYYY(inputVal) {
      if (!inputVal) return "-";
      const d = new Date(inputVal);
      if (isNaN(d)) return "-";
      const dd = String(d.getDate()).padStart(2, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const yyyy = d.getFullYear();
      return `${dd}/${mm}/${yyyy}`;
    }

    function updateSummaryBox(summaryCounts, startInput, endInput) {
      const box = document.getElementById("summaryBox");
      if (!box) return;

      const startStr = formatDateInputToDDMMYYYY(startInput);
      const endStr = formatDateInputToDDMMYYYY(endInput);

      let html = `<div class="summary-box-title">‡∏™‡∏£‡∏∏‡∏õ‡∏à‡∏≠‡∏î‡∏ô‡∏≠‡∏Å‡∏à‡∏∏‡∏î</div>`;

      if (!startInput && !endInput) {
        html += `<div>‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡πà‡∏≠‡∏ô</div>`;
      } else if (Object.keys(summaryCounts).length === 0) {
        html += `<div>‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏ô‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á ${startStr} - ${endStr}</div>`;
      } else {
        html += `
          <div style="margin-bottom:8px; font-size:15px; font-weight:600;">
            ‡∏ä‡πà‡∏ß‡∏á ${startStr} - ${endStr}
          </div>
        `;

        Object.keys(summaryCounts)
          .sort()
          .forEach(lic => {
            const color = getColorForLicense(lic);
            html += `
              <div class="summary-item">
                <div style="font-weight:700; font-size:15px; color:${color};">
                  ‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô ${lic}
                </div>
                <div style="font-size:15px; color:#000000;">
                  ‡∏à‡∏≠‡∏î‡∏ô‡∏≠‡∏Å‡∏à‡∏∏‡∏î ${summaryCounts[lic]} ‡∏à‡∏∏‡∏î
                </div>
              </div>
            `;
          });
      }

      box.innerHTML = html;
    }

    function renderMap() {
      markersLayer.clearLayers();

      const bounds = [];
      renderParkingMarkers(bounds);

      updateLicenseOptionsByCurrentFilters();
      updateDriverOptionsByCurrentFilters();

      const startInput = document.getElementById("startDatetime").value;
      const endInput = document.getElementById("endDatetime").value;
      const licenseFilter = document.getElementById("licenseSelect").value;

      const legendDivOld = document.querySelector(".legend-container");
      if (legendDivOld) legendDivOld.remove();

      if (!startInput && !endInput) {
        if (bounds.length > 0) {
          map.fitBounds(bounds, { padding: [40, 40] });
        }
        updateStatus("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î (‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô)");
        updateSummaryBox({}, startInput, endInput);
        return;
      }

      const filtered = getFilteredData();
      if (filtered.length === 0) {
        if (bounds.length > 0) {
          map.fitBounds(bounds, { padding: [40, 40] });
        }
        updateStatus("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏ï‡∏≤‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏´‡∏°‡∏∏‡∏î parking)");
        updateSummaryBox({}, startInput, endInput);
        return;
      }

      const licenseSummary = computeLicenseSummary(filtered);
      const clusters = clusterByRadius(filtered, 300);
      const licensesInView = new Set();

      clusters.forEach(cluster => {
        const { lat, lng, rows } = cluster;
        if (!rows.length) return;
        if (isInRefZone(lat, lng)) return;

        const sortedRows = rows
          .map(r => ({ row: r, dt: parseDateTime(r[COLUMN.datetime]) }))
          .sort((a, b) => (a.dt || 0) - (b.dt || 0));

        const firstObj = sortedRows[0];
        const lastObj  = sortedRows[sortedRows.length - 1];

        const first = firstObj.row;
        const last  = lastObj.row;

        const startTime = first[COLUMN.datetime] || "-";
        const endTime   = last[COLUMN.datetime]  || "-";

        const startDt = firstObj.dt;
        const endDt   = lastObj.dt;

        let diffMs = null;
        if (startDt && endDt) {
          diffMs = endDt - startDt;
          if (diffMs < MIN_STOP_MS) {
            return;
          }
        }

        let durationText = "-";
        if (diffMs !== null && diffMs >= 0) {
          const totalSec = Math.floor(diffMs / 1000);
          const hours = Math.floor(totalSec / 3600);
          const minutes = Math.floor((totalSec % 3600) / 60);
          const seconds = totalSec % 60;

          if (hours > 0) {
            durationText = `${hours}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")} ‡∏ô.`;
          } else {
            durationText = `${minutes}:${String(seconds).padStart(2, "0")} ‡∏ô‡∏≤‡∏ó‡∏µ`;
          }
        }

        const licenseSet = new Set(rows.map(r => r[COLUMN.license]).filter(Boolean));
        const driverSet  = new Set(rows.map(r => r[COLUMN.driver]).filter(Boolean));

        const licenseText = Array.from(licenseSet).join(", ") || "‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô";
        const driverText  = Array.from(driverSet).join(", ") || "-";

        const locationText = first[COLUMN.locationText] || "-";
        const org          = first[COLUMN.org]          || "-";

        const firstLicense = first[COLUMN.license] || licenseText;
        const color = getColorForLicense(firstLicense);
        licensesInView.add(firstLicense);

        const marker = L.circleMarker([lat, lng], {
          radius: 9,
          color: "#000000",
          weight: 1.5,
          fillColor: color,
          fillOpacity: 0.95
        });

        const popupHtml = `
          <div style="font-size:13px;">
            <strong>‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô:</strong> ${licenseText}<br/>
            <strong>‡∏û‡∏Ç‡∏£:</strong> ${driverText}<br/>
            <strong>‡∏™‡∏±‡∏á‡∏Å‡∏±‡∏î:</strong> ${org}<br/>
            <strong>‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà:</strong> ${locationText}<br/>
            <strong>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡πÉ‡∏ô‡∏£‡∏±‡∏®‡∏°‡∏µ‡∏ô‡∏µ‡πâ:</strong> ${rows.length} ‡∏à‡∏∏‡∏î<br/>
            <strong>‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô:</strong> ${startTime}<br/>
            <strong>‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î:</strong> ${endTime}<br/>
            <strong>‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏à‡∏≠‡∏î:</strong> ${durationText}<br/>
            <a href="https://www.google.com/maps?q=${lat},${lng}" target="_blank" rel="noopener noreferrer">
              ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ô Google Maps
            </a>
          </div>
        `;

        marker.bindPopup(popupHtml);
        marker.addTo(markersLayer);
        bounds.push([lat, lng]);
      });

      if (bounds.length > 0) {
        map.fitBounds(bounds, { padding: [40, 40] });
      }

      let shownCount = 0;
      if (licenseFilter) {
        const keyFilter = normalizeLicense(licenseFilter);
        shownCount = licenseSummary[keyFilter] || 0;
      } else {
        shownCount = Object.values(licenseSummary).reduce((a, b) => a + b, 0);
      }

      updateStatus(
        `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏ô‡∏≠‡∏Å‡∏à‡∏∏‡∏î (‡∏´‡∏•‡∏±‡∏á‡∏ï‡∏±‡∏î Ref ‡πÅ‡∏•‡∏∞‡∏à‡∏≠‡∏î‡πÑ‡∏°‡πà‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ 3 ‡∏ô‡∏≤‡∏ó‡∏µ): ${shownCount.toLocaleString()} ‡∏à‡∏∏‡∏î`
      );

      updateSummaryBox(licenseSummary, startInput, endInput);

      const legend = L.control({ position: "topright" });
      legend.onAdd = function () {
        const div = L.DomUtil.create("div", "legend legend-container");
        div.innerHTML = "<strong>‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏£‡∏ñ</strong><br/>";

        Array.from(licensesInView)
          .sort()
          .forEach(lic => {
            const color = getColorForLicense(lic);
            const row = document.createElement("div");
            row.className = "legend-item";
            const colorBox = document.createElement("span");
            colorBox.className = "legend-color";
            colorBox.style.backgroundColor = color;
            row.appendChild(colorBox);
            const text = document.createElement("span");
            text.textContent = normalizeLicense(lic) || lic;
            row.appendChild(text);
            div.appendChild(row);
          });

        return div;
      };
      legend.addTo(map);
    }

    function escapeCSV(val) {
      if (val === null || val === undefined) return "";
      const s = String(val).replace(/"/g, '""');
      if (/[",\n]/.test(s)) {
        return `"${s}"`;
      }
      return s;
    }

    function buildClusterRecords(filtered) {
      const clusters = clusterByRadius(filtered, 300);
      const records = [];

      clusters.forEach(cluster => {
        const { lat, lng, rows } = cluster;
        if (!rows.length) return;
        if (isInRefZone(lat, lng)) return;

        const sortedRows = rows
          .map(r => ({ row: r, dt: parseDateTime(r[COLUMN.datetime]) }))
          .sort((a, b) => (a.dt || 0) - (b.dt || 0));

        const firstObj = sortedRows[0];
        const lastObj  = sortedRows[sortedRows.length - 1];

        const first = firstObj.row;
        const last  = lastObj.row;

        const startTime = first[COLUMN.datetime] || "-";
        const endTime   = last[COLUMN.datetime]  || "-";

        const startDt = firstObj.dt;
        const endDt   = lastObj.dt;

        let durationText = "-";
        if (startDt && endDt) {
          const diffMs = endDt - startDt;
          if (diffMs < MIN_STOP_MS) {
            return;
          }
          const totalSec = Math.floor(diffMs / 1000);
          const hours = Math.floor(totalSec / 3600);
          const minutes = Math.floor((totalSec % 3600) / 60);
          const seconds = totalSec % 60;

          if (hours > 0) {
            durationText = `${hours}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")} ‡∏ô.`;
          } else {
            durationText = `${minutes}:${String(seconds).padStart(2, "0")} ‡∏ô‡∏≤‡∏ó‡∏µ`;
          }
        }

        const licenseSet = new Set(
          rows.map(r => normalizeLicense(r[COLUMN.license])).filter(Boolean)
        );
        const driverSet  = new Set(rows.map(r => r[COLUMN.driver]).filter(Boolean));

        const licenseText = Array.from(licenseSet).join(", ") || "‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô";
        const driverText  = Array.from(driverSet).join(", ") || "-";

        const locationText = first[COLUMN.locationText] || "-";
        const org          = first[COLUMN.org]          || "-";

        const nearest = getNearestParking(lat, lng);
        const nearestName = nearest.name;

        const firstLicense = normalizeLicense(first[COLUMN.license] || licenseText);

        records.push({
          lat,
          lng,
          rowsCount: rows.length,
          licenseText,
          driverText,
          org,
          locationText,
          nearestName,
          startTime,
          endTime,
          durationText,
          firstLicense: firstLicense || licenseText
        });
      });

      return records;
    }

    function generateReportRecords() {
      const startInput = document.getElementById("startDatetime").value;
      const endInput = document.getElementById("endDatetime").value;

      const filtered = getFilteredData();
      if (!startInput && !endInput) {
        alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤ (Start/End) ‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•");
        return null;
      }
      if (!filtered.length) {
        alert("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏ï‡∏≤‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å");
        return null;
      }

      const records = buildClusterRecords(filtered);
      if (!records.length) {
        alert("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏ô‡∏≠‡∏Å‡∏à‡∏∏‡∏î (‡∏´‡∏•‡∏±‡∏á‡∏ï‡∏±‡∏î Ref ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ 3 ‡∏ô‡∏≤‡∏ó‡∏µ)");
        return null;
      }

      return {
        records,
        startInput,
        endInput
      };
    }

    function exportToExcel() {
      const result = generateReportRecords();
      if (!result) return;
      const { records, startInput, endInput } = result;

      const header = [
        "‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏£‡∏ñ",
        "‡∏ä‡∏∑‡πà‡∏≠ ‡∏û‡∏Ç‡∏£",
        "‡∏™‡∏±‡∏á‡∏Å‡∏±‡∏î",
        "‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà",
        "Lat",
        "Lng",
        "‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡πÉ‡∏ô‡∏Ñ‡∏•‡∏±‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå",
        "‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô",
        "‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î",
        "‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏à‡∏≠‡∏î"
      ];

      const rows = records.map(r => [
        r.licenseText,
        r.driverText,
        r.org,
        r.locationText,
        r.lat.toFixed(6),
        r.lng.toFixed(6),
        r.rowsCount,
        r.startTime,
        r.endTime,
        r.durationText
      ]);

      let csv = "\uFEFF" + header.map(escapeCSV).join(",") + "\n";
      csv += rows.map(row => row.map(escapeCSV).join(",")).join("\n");

      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      const startStr = formatDateInputToDDMMYYYY(startInput).replace(/\//g, "");
      const endStr = formatDateInputToDDMMYYYY(endInput).replace(/\//g, "");
      a.href = url;
      a.download = `stops_${startStr}_${endStr}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function exportToPDF() {
      // ‡πÄ‡∏ä‡πá‡∏Å‡∏ß‡πà‡∏≤ jsPDF ‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
      if (!window.jspdf || !window.jspdf.jsPDF) {
        alert("‡πÑ‡∏°‡πà‡∏û‡∏ö jsPDF ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏ä‡πá‡∏Ñ‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå jsPDF");
        console.error("window.jspdf ‡∏´‡∏£‡∏∑‡∏≠ window.jspdf.jsPDF ‡πÄ‡∏õ‡πá‡∏ô undefined");
        return;
      }

      const { jsPDF } = window.jspdf;   // ‡∏î‡∏∂‡∏á‡∏Ñ‡∏•‡∏≤‡∏™ jsPDF ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏à‡∏≤‡∏Å UMD

      const result = generateReportRecords();
      if (!result) return;
      const { records, startInput, endInput } = result;

      const startStr = formatDateInputToDDMMYYYY(startInput);
      const endStr   = formatDateInputToDDMMYYYY(endInput);

      const doc = new jsPDF({
        orientation: "landscape",
        unit: "mm",
        format: "a4"
      });

      // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ä‡∏∑‡πà‡∏≠‡∏ü‡∏≠‡∏ô‡∏ï‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ "sarabun" ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö ‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠‡∏ô‡∏±‡πâ‡∏ô
      let sarabunFontName = null;
      if (typeof doc.getFontList === "function") {
        const fontList = doc.getFontList();
        for (const name of Object.keys(fontList)) {
          if (name.toLowerCase().includes("sarabun")) {
            sarabunFontName = name;
            break;
          }
        }
      }
      if (sarabunFontName) {
        doc.setFont(sarabunFontName, "normal");
      } else {
        // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏ü‡∏≠‡∏ô‡∏ï‡πå‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        doc.setFont("helvetica", "normal");
      }

      // ‡∏´‡∏±‡∏ß‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏©
      doc.setFontSize(14);
      doc.text("‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏ô‡∏≠‡∏Å‡∏à‡∏∏‡∏î", 14, 12);
      doc.setFontSize(10);
      doc.text(`‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà ${startStr} ‡∏ñ‡∏∂‡∏á ${endStr}`, 14, 18);
      doc.text(
        `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏•‡∏±‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏ô‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${records.length.toLocaleString()} ‡∏à‡∏∏‡∏î`,
        14,
        24
      );

      const head = [[
        "#",
        "‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏£‡∏ñ",
        "‡∏ä‡∏∑‡πà‡∏≠ ‡∏û‡∏Ç‡∏£",
        "‡∏™‡∏±‡∏á‡∏Å‡∏±‡∏î",
        "‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà",
        "‡∏û‡∏¥‡∏Å‡∏±‡∏î (Lat,Lng)",
        "‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡πÉ‡∏ô‡∏Ñ‡∏•‡∏±‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå",
        "‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô",
        "‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î",
        "‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏à‡∏≠‡∏î"
      ]];

      const body = records.map((r, idx) => ([
        idx + 1,
        r.licenseText,
        r.driverText,
        r.org,
        r.locationText,
        `${r.lat.toFixed(6)}, ${r.lng.toFixed(6)}`,
        r.rowsCount,
        r.startTime,
        r.endTime,
        r.durationText
      ]));

      doc.autoTable({
        startY: 28,
        head,
        body,
        styles: {
          font: sarabunFontName || "helvetica",
          fontSize: 8,
          cellPadding: 2,
          halign: "center",
          valign: "middle",
          overflow: "linebreak"
        },
        headStyles: {
          font: sarabunFontName || "helvetica",
          fontStyle: "normal",
          fillColor: [243, 244, 246],
          textColor: 0
        },
        columnStyles: {
          1: { cellWidth: 23 },
          2: { cellWidth: 22 },
          4: { halign: "left", cellWidth: 45 },
          5: { halign: "left", cellWidth: 40 }
        },
        margin: { left: 10, right: 10 }
      });

      const fileStart = startStr.replace(/\//g, "");
      const fileEnd   = endStr.replace(/\//g, "");
      doc.save(`stops_${fileStart}_${fileEnd}.pdf`);
    }

    function loadParkingData(callback) {
      Papa.parse(PARKING_CSV_URL, {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: function (results) {
          parkingData = results.data || [];
          if (callback) callback();
        },
        error: function (err) {
          console.error("Parking sheet error:", err);
          parkingData = [];
          if (callback) callback();
        }
      });
    }

    function loadRefData(callback) {
      Papa.parse(REF_CSV_URL, {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: function (results) {
          const rows = results.data || [];
          refData = [];
          rows.forEach(row => {
            const { lat, lng } = parseRefLatLng(row);
            if (!Number.isNaN(lat) && !Number.isNaN(lng)) {
              refData.push({ lat, lng });
            }
          });
          if (callback) callback();
        },
        error: function (err) {
          console.error("Ref sheet error:", err);
          refData = [];
          if (callback) callback();
        }
      });
    }

    function loadData() {
      updateStatus("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Google Sheets...");

      Papa.parse(SHEET_CSV_URL, {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: function (results) {
          rawData = results.data || [];
          loadParkingData(() => {
            loadRefData(() => {
              updateStatus(
                `‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î ${rawData.length.toLocaleString()} ‡πÅ‡∏ñ‡∏ß, parking ${parkingData.length.toLocaleString()} ‡∏à‡∏∏‡∏î, Ref ${refData.length.toLocaleString()} ‡∏à‡∏∏‡∏î`
              );
              populateFilters();
              renderMap();
            });
          });
        },
        error: function (err) {
          console.error("Main sheet error:", err);
          updateStatus("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î");
        }
      });
    }

    // ====== LOGIN LOGIC ======
    const VALID_ID = "kcpetro9999";
    const VALID_PASS = "kcpetropass9999";

    function handleLogin() {
      const id = document.getElementById("loginId").value.trim();
      const pass = document.getElementById("loginPass").value.trim();
      const errorEl = document.getElementById("loginError");

      if (id === VALID_ID && pass === VALID_PASS) {
        errorEl.textContent = "";
        const overlay = document.getElementById("loginOverlay");
        overlay.style.display = "none";
        loadData();
      } else {
        errorEl.textContent = "ID ‡∏´‡∏£‡∏∑‡∏≠ Password ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á";
      }
    }

    window.addEventListener("DOMContentLoaded", () => {
      initMap();

      updateStatus("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Google Sheets");

      document.getElementById("loginBtn")
        .addEventListener("click", handleLogin);

      document.getElementById("loginPass")
        .addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            handleLogin();
          }
        });

      document.getElementById("applyFilterBtn")
        .addEventListener("click", () => renderMap());

      document.getElementById("resetFilterBtn")
        .addEventListener("click", () => {
          resetFilters();
        });

      document.getElementById("exportExcelBtn")
        .addEventListener("click", exportToExcel);

      document.getElementById("exportPdfBtn")
        .addEventListener("click", exportToPDF);
    });
  </script>
</body>
</html>
