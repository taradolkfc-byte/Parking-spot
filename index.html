<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <title>‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏£‡∏ñ‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô 2568</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
    }
    header {
      padding: 12px 16px;
      background: #1f2937;
      color: #fff;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    header h1 {
      font-size: 18px;
      margin: 0;
    }
    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      font-size: 13px;
    }
    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .filter-group label {
      font-size: 11px;
      color: #e5e7eb;
    }
    .filter-group input,
    .filter-group select,
    .filter-group button {
      font-size: 12px;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #9ca3af;
    }
    .filter-group button {
      border: none;
      cursor: pointer;
      background: #3b82f6;
      color: white;
      font-weight: 600;
    }
    .filter-group button.secondary {
      background: #6b7280;
    }

    #map {
      width: 100%;
      height: calc(100vh - 70px);
    }

    .legend {
      background: white;
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1.5;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.25);
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid #4b5563;
    }

    .status-bar {
      position: absolute;
      z-index: 500;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(31,41,55,0.85);
      color: #e5e7eb;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
    }

    .summary-box {
      background: white;
      padding: 10px 12px;
      font-size: 14px;
      line-height: 1.6;
      border-radius: 8px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.3);
      max-width: 320px;
      margin-top: 48px;
    }
    .summary-box-title {
      font-weight: 700;
      font-size: 15px;
      margin-bottom: 8px;
    }
    .summary-item {
      margin-bottom: 8px;
    }
  </style>
</head>
<body>
  <header>
    <h1>üìç ‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏£‡∏ñ‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô 2568</h1>
    <div class="filters">
      <div class="filter-group">
        <label for="startDatetime">‡∏à‡∏≤‡∏Å‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤ (Start)</label>
        <input type="datetime-local" id="startDatetime" />
      </div>
      <div class="filter-group">
        <label for="endDatetime">‡∏ñ‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤ (End)</label>
        <input type="datetime-local" id="endDatetime" />
      </div>
      <div class="filter-group">
        <label for="licenseSelect">‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏£‡∏ñ</label>
        <select id="licenseSelect">
          <option value="">‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</option>
        </select>
      </div>
      <div class="filter-group">
        <label for="driverSelect">‡∏ä‡∏∑‡πà‡∏≠ ‡∏û‡∏Ç‡∏£</label>
        <select id="driverSelect">
          <option value="">‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</option>
        </select>
      </div>
      <div class="filter-group">
        <label>&nbsp;</label>
        <button id="applyFilterBtn">Apply Filter</button>
      </div>
      <div class="filter-group">
        <label>&nbsp;</label>
        <button id="resetFilterBtn" class="secondary">Reset</button>
      </div>
    </div>
  </header>

  <div id="map"></div>
  <div class="status-bar" id="statusBar">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Google Sheets...</div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- PapaParse -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    const SHEET_CSV_URL =
      "https://docs.google.com/spreadsheets/d/1hjEeceDdHwOgZ4hbcE8bOfitZVhKB7KBtVHmF5p4iGY/export?format=csv&gid=365287996";

    const PARKING_CSV_URL =
      "https://docs.google.com/spreadsheets/d/1hjEeceDdHwOgZ4hbcE8bOfitZVhKB7KBtVHmF5p4iGY/export?format=csv&gid=1849750877";

    const REF_CSV_URL =
      "https://docs.google.com/spreadsheets/d/1hjEeceDdHwOgZ4hbcE8bOfitZVhKB7KBtVHmF5p4iGY/export?format=csv&gid=1061454761";

    const COLUMN = {
      license: "‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô",
      datetime: "‡∏ß‡∏±‡∏ô‡πÅ‡∏•‡∏∞‡πÄ‡∏ß‡∏•‡∏≤",
      lat: "‡∏•‡∏∞",
      lng: "‡∏•‡∏≠‡∏á",
      org: "‡∏™‡∏±‡∏á‡∏Å‡∏±‡∏î",
      distance: "‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏∏‡∏î‡πÉ‡∏Å‡∏•‡πâ‡∏™‡∏∏‡∏î",
      locationText: "‡∏£‡∏∞‡∏ö‡∏∏‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà",
      driver: "‡∏ä‡∏∑‡πà‡∏≠ ‡∏û‡∏Ç‡∏£"
    };

    const PARKING_COLUMN = {
      lat: "‡∏•‡∏∞",
      lng: "‡∏•‡∏≠‡∏á",
      name: "‡∏ä‡∏∑‡πà‡∏≠‡∏à‡∏∏‡∏î",
      locationText: "‡∏£‡∏∞‡∏ö‡∏∏‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà",
      note: "‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏"
    };

    let rawData = [];
    let parkingData = [];
    let refData = [];  // {lat, lng}

    let map, markersLayer, parkingLayer;
    let summaryControl;
    const licenseColorMap = {};

    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏µ‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡πÅ‡∏ö‡∏ö fixed 3 ‡∏Ñ‡∏±‡∏ô (‡πÅ‡∏Å‡πâ‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏ô‡∏µ‡πâ‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£)
    const FIXED_LICENSE_COLORS = {
      "70-1873-63": "#cc0000",  // üî¥ ‡πÅ‡∏î‡∏á‡πÅ‡∏ö‡∏ö‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á
      "70-1927-64": "#1d4ed8",  // ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô
      "70-2484-70": "#eab308"   // ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á
    };

    const colorPalette = [
      "#ec4899",
      "#6366f1",
      "#f97316",
      "#22c55e",
      "#a855f7",
      "#f59e0b",
      "#fb7185"
    ];

    const MIN_STOP_MS = 3 * 60 * 1000;

    function updateStatus(text) {
      document.getElementById("statusBar").textContent = text;
    }

    function getColorForLicense(license) {
      if (!license) return "#000000";
      if (FIXED_LICENSE_COLORS[license]) {
        licenseColorMap[license] = FIXED_LICENSE_COLORS[license];
        return FIXED_LICENSE_COLORS[license];
      }
      if (!licenseColorMap[license]) {
        const index = Object.keys(licenseColorMap).length % colorPalette.length;
        licenseColorMap[license] = colorPalette[index];
      }
      return licenseColorMap[license];
    }

    function parseDateTime(str) {
      if (!str) return null;
      const s = String(str).trim();
      const [datePart, timePart] = s.split(" ");
      if (!datePart || !timePart) return null;
      const [y, m, d] = datePart.split("-").map(Number);
      const [hh, mm = 0, ss = 0] = timePart.split(":").map(Number);
      if ([y, m, d].some(v => isNaN(v))) return null;
      return new Date(y, m - 1, d, hh || 0, mm || 0, ss || 0);
    }

    function haversineMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    const TRAFFIC_LIGHT_ZONES = [];

    function isInTrafficLightZone(lat, lng) {
      for (const z of TRAFFIC_LIGHT_ZONES) {
        const d = haversineMeters(lat, lng, z.lat, z.lng);
        if (d <= z.radiusMeters) return true;
      }
      return false;
    }

    function parseRefLatLng(row) {
      let lat = NaN;
      let lng = NaN;

      for (const [key, value] of Object.entries(row)) {
        const lowerKey = key.toLowerCase();
        if (Number.isNaN(lat) && (lowerKey.includes("‡∏•‡∏∞") || lowerKey.includes("lat"))) {
          const n = parseFloat(value);
          if (!Number.isNaN(n)) lat = n;
        }
        if (Number.isNaN(lng) && (lowerKey.includes("‡∏•‡∏≠‡∏á") || lowerKey.includes("lng") || lowerKey.includes("lon"))) {
          const n = parseFloat(value);
          if (!Number.isNaN(n)) lng = n;
        }
      }

      if (Number.isNaN(lat) || Number.isNaN(lng)) {
        const nums = Object.values(row)
          .map(v => parseFloat(v))
          .filter(n => !Number.isNaN(n));

        for (let i = 0; i < nums.length - 1; i++) {
          const a = nums[i];
          const b = nums[i + 1];
          if (a >= 5 && a <= 25 && b >= 95 && b <= 110) {
            lat = a;
            lng = b;
            break;
          }
        }
      }

      return { lat, lng };
    }

    function isInRefZone(lat, lng) {
      if (!refData.length) return false;
      for (const p of refData) {
        const d = haversineMeters(lat, lng, p.lat, p.lng);
        if (d <= 300) return true;
      }
      return false;
    }

    function getFilteredData() {
      const startInput = document.getElementById("startDatetime").value;
      const endInput = document.getElementById("endDatetime").value;
      const licenseFilter = document.getElementById("licenseSelect").value;
      const driverFilter = document.getElementById("driverSelect").value;

      const start = startInput ? new Date(startInput) : null;
      const end = endInput ? new Date(endInput) : null;

      return rawData.filter(row => {
        const lat = parseFloat(row[COLUMN.lat]);
        const lng = parseFloat(row[COLUMN.lng]);
        if (isNaN(lat) || isNaN(lng)) return false;

        if (isInTrafficLightZone(lat, lng)) return false;
        if (isInRefZone(lat, lng)) return false;

        const dt = parseDateTime(row[COLUMN.datetime]);
        if ((start || end) && !dt) return false;
        if (start && dt < start) return false;
        if (end && dt > end) return false;

        if (licenseFilter && row[COLUMN.license] !== licenseFilter) return false;
        if (driverFilter && row[COLUMN.driver] !== driverFilter) return false;

        return true;
      });
    }

    function updateLicenseOptionsByCurrentFilters() {
      const startInput = document.getElementById("startDatetime").value;
      const endInput = document.getElementById("endDatetime").value;
      const driverFilter = document.getElementById("driverSelect").value;
      const licenseSelect = document.getElementById("licenseSelect");

      const start = startInput ? new Date(startInput) : null;
      const end = endInput ? new Date(endInput) : null;

      const prevValue = licenseSelect.value;
      const licenseSet = new Set();

      rawData.forEach(row => {
        const lat = parseFloat(row[COLUMN.lat]);
        const lng = parseFloat(row[COLUMN.lng]);
        if (isNaN(lat) || isNaN(lng)) return;
        if (isInTrafficLightZone(lat, lng)) return;
        if (isInRefZone(lat, lng)) return;

        const dt = parseDateTime(row[COLUMN.datetime]);
        if ((start || end) && !dt) return;
        if (start && dt < start) return;
        if (end && dt > end) return;
        if (driverFilter && row[COLUMN.driver] !== driverFilter) return;

        if (row[COLUMN.license]) licenseSet.add(row[COLUMN.license]);
      });

      while (licenseSelect.options.length > 1) {
        licenseSelect.remove(1);
      }

      Array.from(licenseSet).sort().forEach(lic => {
        const opt = document.createElement("option");
        opt.value = lic;
        opt.textContent = lic;
        licenseSelect.appendChild(opt);
      });

      if (prevValue && licenseSet.has(prevValue)) {
        licenseSelect.value = prevValue;
      } else {
        licenseSelect.value = "";
      }
    }

    function updateDriverOptionsByCurrentFilters() {
      const startInput = document.getElementById("startDatetime").value;
      const endInput = document.getElementById("endDatetime").value;
      const licenseFilter = document.getElementById("licenseSelect").value;
      const driverSelect = document.getElementById("driverSelect");

      const start = startInput ? new Date(startInput) : null;
      const end = endInput ? new Date(endInput) : null;

      const prevValue = driverSelect.value;
      const driverSet = new Set();

      rawData.forEach(row => {
        const lat = parseFloat(row[COLUMN.lat]);
        const lng = parseFloat(row[COLUMN.lng]);
        if (isNaN(lat) || isNaN(lng)) return;
        if (isInTrafficLightZone(lat, lng)) return;
        if (isInRefZone(lat, lng)) return;

        const dt = parseDateTime(row[COLUMN.datetime]);
        if ((start || end) && !dt) return;
        if (start && dt < start) return;
        if (end && dt > end) return;
        if (licenseFilter && row[COLUMN.license] !== licenseFilter) return;

        if (row[COLUMN.driver]) driverSet.add(row[COLUMN.driver]);
      });

      while (driverSelect.options.length > 1) {
        driverSelect.remove(1);
      }

      Array.from(driverSet).sort().forEach(drv => {
        const opt = document.createElement("option");
        opt.value = drv;
        opt.textContent = drv;
        driverSelect.appendChild(opt);
      });

      if (prevValue && driverSet.has(prevValue)) {
        driverSelect.value = prevValue;
      } else {
        driverSelect.value = "";
      }
    }

    function populateFilters() {
      updateLicenseOptionsByCurrentFilters();
      updateDriverOptionsByCurrentFilters();
    }

    function resetFilters() {
      document.getElementById("startDatetime").value = "";
      document.getElementById("endDatetime").value = "";
      document.getElementById("licenseSelect").value = "";
      document.getElementById("driverSelect").value = "";
      updateLicenseOptionsByCurrentFilters();
      updateDriverOptionsByCurrentFilters();
      renderMap();
    }

    function initMap() {
      map = L.map("map").setView([16.3, 103.3], 7);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);
      markersLayer = L.layerGroup().addTo(map);
      parkingLayer = L.layerGroup().addTo(map);

      summaryControl = L.control({ position: "topleft" });
      summaryControl.onAdd = function () {
        const div = L.DomUtil.create("div", "summary-box");
        div.id = "summaryBox";
        div.innerHTML = `
          <div class="summary-box-title">‡∏™‡∏£‡∏∏‡∏õ‡∏à‡∏≠‡∏î‡∏ô‡∏≠‡∏Å‡∏à‡∏∏‡∏î</div>
          <div>‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡πà‡∏≠‡∏ô</div>
        `;
        return div;
      };
      summaryControl.addTo(map);
    }

    function clusterByRadius(data, radiusMeters = 300) {
      const clusters = [];
      const MAX_CLUSTER_SPAN_MS = 20 * 60 * 60 * 1000;

      const enriched = data
        .map(row => ({
          row,
          dt: parseDateTime(row[COLUMN.datetime])
        }))
        .sort((a, b) => (a.dt || 0) - (b.dt || 0));

      enriched.forEach(({ row, dt }) => {
        const lat = parseFloat(row[COLUMN.lat]);
        const lng = parseFloat(row[COLUMN.lng]);
        if (isNaN(lat) || isNaN(lng)) return;

        let found = null;

        for (const cluster of clusters) {
          const d = haversineMeters(lat, lng, cluster.lat, cluster.lng);
          if (d > radiusMeters) continue;
          if (!dt || !cluster.maxDt) continue;

          const diffMs = dt - cluster.maxDt;
          if (diffMs >= 0 && diffMs <= MAX_CLUSTER_SPAN_MS) {
            found = cluster;
            break;
          }
        }

        if (found) {
          found.rows.push(row);
          if (dt) {
            if (!found.minDt || dt < found.minDt) found.minDt = dt;
            if (!found.maxDt || dt > found.maxDt) found.maxDt = dt;
          }
        } else {
          clusters.push({
            lat,
            lng,
            rows: [row],
            minDt: dt || null,
            maxDt: dt || null
          });
        }
      });

      return clusters;
    }

    function computeLicenseSummary(data) {
      const result = {};
      if (!data.length) return result;

      const licenseMap = new Map();
      data.forEach(row => {
        const lic = row[COLUMN.license] || "‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô";
        if (!licenseMap.has(lic)) licenseMap.set(lic, []);
        licenseMap.get(lic).push(row);
      });

      licenseMap.forEach((rows, lic) => {
        const clusters = clusterByRadius(rows, 300);
        let count = 0;

        clusters.forEach(cluster => {
          const { lat, lng, rows: cRows } = cluster;
          if (!cRows.length) return;
          if (isInRefZone(lat, lng)) return;

          const sortedRows = cRows
            .map(r => ({ dt: parseDateTime(r[COLUMN.datetime]) }))
            .sort((a, b) => (a.dt || 0) - (b.dt || 0));

          const firstDt = sortedRows[0].dt;
          const lastDt  = sortedRows[sortedRows.length - 1].dt;

          if (firstDt && lastDt) {
            const diffMs = lastDt - firstDt;
            if (diffMs < MIN_STOP_MS) return;
          }
          count++;
        });

        if (count > 0) result[lic] = count;
      });

      return result;
    }

    function renderParkingMarkers(boundsArray) {
      parkingLayer.clearLayers();
      if (!parkingData.length) return;

      const defaultIcon = L.icon({
        iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png",
        iconRetinaUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png",
        shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
        iconSize: [28, 44],
        iconAnchor: [14, 44],
        popupAnchor: [0, -32],
        shadowSize: [41, 41]
      });

      parkingData.forEach(row => {
        const { lat, lng } = parseRefLatLng(row);
        if (Number.isNaN(lat) || Number.isNaN(lng)) return;

        const vals = Object.values(row);
        const name =
          row[PARKING_COLUMN.name] ||
          row[PARKING_COLUMN.locationText] ||
          row["‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà"] ||
          vals[0] ||
          "-";

        const note = row[PARKING_COLUMN.note] || "";

        const popupHtml = `
          <div style="font-size:13px;">
            <strong>‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î/‡∏ó‡∏µ‡πà‡∏à‡∏≠‡∏î‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô:</strong> ${name}<br/>
            ${note ? `<strong>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:</strong> ${note}<br/>` : ""}
            <strong>Lat,Lng:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br/>
            <a href="https://www.google.com/maps?q=${lat},${lng}" target="_blank" rel="noopener noreferrer">
              ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ô Google Maps
            </a>
          </div>
        `;

        const m = L.marker([lat, lng], { icon: defaultIcon });
        m.bindPopup(popupHtml);
        m.bindTooltip(name, { direction: "top", offset: [0, -28] });
        m.addTo(parkingLayer);

        if (boundsArray) boundsArray.push([lat, lng]);
      });
    }

    function formatDateInputToDDMMYYYY(inputVal) {
      if (!inputVal) return "-";
      const d = new Date(inputVal);
      if (isNaN(d)) return "-";
      const dd = String(d.getDate()).padStart(2, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const yyyy = d.getFullYear();
      return `${dd}/${mm}/${yyyy}`;
    }

    function updateSummaryBox(summaryCounts, startInput, endInput) {
      const box = document.getElementById("summaryBox");
      if (!box) return;

      const startStr = formatDateInputToDDMMYYYY(startInput);
      const endStr = formatDateInputToDDMMYYYY(endInput);

      let html = `<div class="summary-box-title">‡∏™‡∏£‡∏∏‡∏õ‡∏à‡∏≠‡∏î‡∏ô‡∏≠‡∏Å‡∏à‡∏∏‡∏î</div>`;

      if (!startInput && !endInput) {
        html += `<div>‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡πà‡∏≠‡∏ô</div>`;
      } else if (Object.keys(summaryCounts).length === 0) {
        html += `<div>‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏ô‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á ${startStr} - ${endStr}</div>`;
      } else {
        html += `
          <div style="margin-bottom:8px; font-size:15px; font-weight:600;">
            ‡∏ä‡πà‡∏ß‡∏á ${startStr} - ${endStr}
          </div>
        `;

        Object.keys(summaryCounts)
          .sort()
          .forEach(lic => {
            const color = getColorForLicense(lic);
            html += `
              <div class="summary-item">
                <div style="font-weight:700; font-size:15px; color:${color};">
                  ‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô ${lic}
                </div>
                <div style="font-size:15px; color:#000000;">
                  ‡∏à‡∏≠‡∏î‡∏ô‡∏≠‡∏Å‡∏à‡∏∏‡∏î ${summaryCounts[lic]} ‡∏à‡∏∏‡∏î
                </div>
              </div>
            `;
          });
      }

      box.innerHTML = html;
    }

    function renderMap() {
      markersLayer.clearLayers();

      const bounds = [];
      renderParkingMarkers(bounds);

      updateLicenseOptionsByCurrentFilters();
      updateDriverOptionsByCurrentFilters();

      const startInput = document.getElementById("startDatetime").value;
      const endInput = document.getElementById("endDatetime").value;
      const licenseFilter = document.getElementById("licenseSelect").value;

      const legendDivOld = document.querySelector(".legend-container");
      if (legendDivOld) legendDivOld.remove();

      if (!startInput && !endInput) {
        if (bounds.length > 0) {
          map.fitBounds(bounds, { padding: [40, 40] });
        }
        updateStatus("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î (‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô)");
        updateSummaryBox({}, startInput, endInput);
        return;
      }

      const filtered = getFilteredData();
      if (filtered.length === 0) {
        if (bounds.length > 0) {
          map.fitBounds(bounds, { padding: [40, 40] });
        }
        updateStatus("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏ï‡∏≤‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏´‡∏°‡∏∏‡∏î parking)");
        updateSummaryBox({}, startInput, endInput);
        return;
      }

      const licenseSummary = computeLicenseSummary(filtered);
      const clusters = clusterByRadius(filtered, 300);
      const licensesInView = new Set();

      clusters.forEach(cluster => {
        const { lat, lng, rows } = cluster;
        if (!rows.length) return;
        if (isInRefZone(lat, lng)) return;

        const sortedRows = rows
          .map(r => ({ row: r, dt: parseDateTime(r[COLUMN.datetime]) }))
          .sort((a, b) => (a.dt || 0) - (b.dt || 0));

        const firstObj = sortedRows[0];
        const lastObj  = sortedRows[sortedRows.length - 1];

        const first = firstObj.row;
        const last  = lastObj.row;

        const startTime = first[COLUMN.datetime] || "-";
        const endTime   = last[COLUMN.datetime]  || "-";

        const startDt = firstObj.dt;
        const endDt   = lastObj.dt;
        if (startDt && endDt) {
          const diffMs = endDt - startDt;
          if (diffMs < MIN_STOP_MS) {
            return;
          }
        }

        const licenseSet = new Set(rows.map(r => r[COLUMN.license]).filter(Boolean));
        const driverSet  = new Set(rows.map(r => r[COLUMN.driver]).filter(Boolean));

        const licenseText = Array.from(licenseSet).join(", ") || "‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô";
        const driverText  = Array.from(driverSet).join(", ") || "-";

        const locationText = first[COLUMN.locationText] || "-";
        const distance     = first[COLUMN.distance]     || "-";
        const org          = first[COLUMN.org]          || "-";

        const firstLicense = first[COLUMN.license] || licenseText;
        const color = getColorForLicense(firstLicense);
        licensesInView.add(firstLicense);

        const marker = L.circleMarker([lat, lng], {
          radius: 9,
          color: "#000000",
          weight: 1.5,
          fillColor: color,
          fillOpacity: 0.95
        });

        const popupHtml = `
          <div style="font-size:13px;">
            <strong>‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô:</strong> ${licenseText}<br/>
            <strong>‡∏û‡∏Ç‡∏£:</strong> ${driverText}<br/>
            <strong>‡∏™‡∏±‡∏á‡∏Å‡∏±‡∏î:</strong> ${org}<br/>
            <strong>‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà:</strong> ${locationText}<br/>
            <strong>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡πÉ‡∏ô‡∏£‡∏±‡∏®‡∏°‡∏µ‡∏ô‡∏µ‡πâ:</strong> ${rows.length} ‡∏à‡∏∏‡∏î<br/>
            <strong>‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô:</strong> ${startTime}<br/>
            <strong>‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î:</strong> ${endTime}<br/>
            <strong>‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏∏‡∏î‡πÉ‡∏Å‡∏•‡πâ‡∏™‡∏∏‡∏î:</strong> ${distance}<br/>
            <strong>Lat,Lng:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br/>
            <a href="https://www.google.com/maps?q=${lat},${lng}" target="_blank" rel="noopener noreferrer">
              ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ô Google Maps
            </a>
          </div>
        `;

        marker.bindPopup(popupHtml);
        marker.addTo(markersLayer);
        bounds.push([lat, lng]);
      });

      if (bounds.length > 0) {
        map.fitBounds(bounds, { padding: [40, 40] });
      }

      let shownCount = 0;
      if (licenseFilter) {
        shownCount = licenseSummary[licenseFilter] || 0;
      } else {
        shownCount = Object.values(licenseSummary).reduce((a, b) => a + b, 0);
      }

      updateStatus(
        `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î‡∏ô‡∏≠‡∏Å‡∏à‡∏∏‡∏î (‡∏´‡∏•‡∏±‡∏á‡∏ï‡∏±‡∏î Ref ‡πÅ‡∏•‡∏∞‡∏à‡∏≠‡∏î‡πÑ‡∏°‡πà‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ 3 ‡∏ô‡∏≤‡∏ó‡∏µ): ${shownCount.toLocaleString()} ‡∏à‡∏∏‡∏î`
      );

      updateSummaryBox(licenseSummary, startInput, endInput);

      const legend = L.control({ position: "topright" });
      legend.onAdd = function () {
        const div = L.DomUtil.create("div", "legend legend-container");
        div.innerHTML = "<strong>‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏£‡∏ñ</strong><br/>";

        Array.from(licensesInView)
          .sort()
          .forEach(lic => {
            const color = getColorForLicense(lic);
            const row = document.createElement("div");
            row.className = "legend-item";
            const colorBox = document.createElement("span");
            colorBox.className = "legend-color";
            colorBox.style.backgroundColor = color;
            row.appendChild(colorBox);
            const text = document.createElement("span");
            text.textContent = lic;
            row.appendChild(text);
            div.appendChild(row);
          });

        return div;
      };
      legend.addTo(map);
    }

    function loadParkingData(callback) {
      Papa.parse(PARKING_CSV_URL, {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: function (results) {
          parkingData = results.data || [];
          if (callback) callback();
        },
        error: function (err) {
          console.error("Parking sheet error:", err);
          parkingData = [];
          if (callback) callback();
        }
      });
    }

    function loadRefData(callback) {
      Papa.parse(REF_CSV_URL, {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: function (results) {
          const rows = results.data || [];
          refData = [];
          rows.forEach(row => {
            const { lat, lng } = parseRefLatLng(row);
            if (!Number.isNaN(lat) && !Number.isNaN(lng)) {
              refData.push({ lat, lng });
            }
          });
          if (callback) callback();
        },
        error: function (err) {
          console.error("Ref sheet error:", err);
          refData = [];
          if (callback) callback();
        }
      });
    }

    function loadData() {
      updateStatus("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Google Sheets...");

      Papa.parse(SHEET_CSV_URL, {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: function (results) {
          rawData = results.data || [];
          loadParkingData(() => {
            loadRefData(() => {
              updateStatus(
                `‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î ${rawData.length.toLocaleString()} ‡πÅ‡∏ñ‡∏ß, parking ${parkingData.length.toLocaleString()} ‡∏à‡∏∏‡∏î, Ref ${refData.length.toLocaleString()} ‡∏à‡∏∏‡∏î`
              );
              populateFilters();
              renderMap();
            });
          });
        },
        error: function (err) {
          console.error("Main sheet error:", err);
          updateStatus("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∏‡∏î‡∏à‡∏≠‡∏î");
        }
      });
    }

    window.addEventListener("DOMContentLoaded", () => {
      initMap();
      loadData();

      document
        .getElementById("applyFilterBtn")
        .addEventListener("click", () => renderMap());

      document
        .getElementById("resetFilterBtn")
        .addEventListener("click", () => {
          resetFilters();
        });
    });
  </script>
</body>
</html>
